<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dict>
    <entry key="blockstrategy">
        <dict>
            <entry key="name">
                <string>net.postchain.base.BaseBlockBuildingStrategy</string>
            </entry>
        </dict>
    </entry>
    <entry key="config_consensus_strategy">
        <string>HEADER_HASH</string>
    </entry>
    <entry key="configurationfactory">
        <string>net.postchain.gtx.GTXBlockchainConfigurationFactory</string>
    </entry>
    <entry key="gtx">
        <dict>
            <entry key="modules">
                <array>
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                    <string>net.postchain.gtx.StandardOpsGTXModule</string>
                </array>
            </entry>
            <entry key="rell">
                <dict>
                    <entry key="moduleArgs">
                        <dict>
                            <entry key="lib.ft4.accounts">
                                <dict>
                                    <entry key="rate_limit_active">
                                        <int>1</int>
                                    </entry>
                                    <entry key="rate_limit_max_points">
                                        <int>10</int>
                                    </entry>
                                    <entry key="rate_limit_points_at_account_creation">
                                        <int>1</int>
                                    </entry>
                                    <entry key="rate_limit_recovery_time">
                                        <int>5000</int>
                                    </entry>
                                </dict>
                            </entry>
                            <entry key="lib.ft4.admin">
                                <dict>
                                    <entry key="admin_pubkey">
                                        <string>023FE75CA3C81C6E1666CB9ECC3F4542AFF30A2C9B4970FF7413E1A17A885FE18F</string>
                                    </entry>
                                </dict>
                            </entry>
                        </dict>
                    </entry>
                    <entry key="modules">
                        <array>
                            <string>development</string>
                        </array>
                    </entry>
                    <entry key="sources">
                        <dict>
                            <entry key="accounts/functions.rell">
                                <string>function create_auth_descriptor(
    signer: byte_array,
    permissions: list&lt;text&gt; = ["A", "T"],
    rules: gtv = null.to_gtv()
): ft4.accounts.auth_descriptor {
    return ft4.accounts.auth_descriptor(
        ft4.accounts.auth_type.ES,
        [
            set(permissions).to_gtv(),
            signer.to_hex().to_gtv()
        ],
        rules
    );
}</string>
                            </entry>
                            <entry key="accounts/model.rell">
                                <string>entity user {
  mutable name;
  key id: byte_array;
  key account;
}

entity user_history {
  index account;
  last_name_change: timestamp;
}
</string>
                            </entry>
                            <entry key="accounts/module.rell">
                                <string>module;

import lib.ft4.accounts.{ account, single_sig_auth_descriptor };
import lib.ft4.auth;
import lib.ft4.ft4_basic_dev.*;
import rell_modules.time;</string>
                            </entry>
                            <entry key="accounts/operations.rell">
                                <string>operation change_username(new_username: text) {
    val account = auth.authenticate();
    val user = user @ { account };

    if (not exists(user_history @? { .account == account } limit 1)) {
        require(not exists(user @? { .name == new_username }), "Username is already taken");
        create user_history ( account = account, last_name_change = time.now() );
        update user @ { .account == account } ( name = new_username );
    } else {
        val currentTime = time.now();
        val timestamp = user_history @ { .account == account } ( @sort_desc .last_name_change ) limit 1;

        require(currentTime - timestamp &gt;= 60 * 1000, "You can change your username only once per 1 minute");
        require(not exists(user @? { .name == new_username }), "Username is already taken");

        create user_history ( account = account, last_name_change = time.now() );
        update user @ { .account == account } ( name = new_username );
    }
}
</string>
                            </entry>
                            <entry key="accounts/queries.rell">
                                <string>query get_user_name(account_id: byte_array) {
    return user @ { .id == account_id } ( .name );
}

query get_all_accounts() = ft4.acc.account @* { } ( .id );
</string>
                            </entry>
                            <entry key="canvas/admin/module.rell">
                                <string>@mount("admin.canvas")

module;

import ^.*;</string>
                            </entry>
                            <entry key="canvas/admin/operations.rell">
                                <string>operation update_canvas_zoomScale(minScale: decimal, maxScale: decimal) {
    ft4.admin.require_admin();
    set_canvas_zoomScale(minScale, maxScale);
}</string>
                            </entry>
                            <entry key="canvas/functions.rell">
                                <string>function get_cell(location) {
    return cell @ { .location == location };
}

function require_is_signer(pubkey) = require(op_context.is_signer(pubkey), "User must sign this operation");

function require_user(id: byte_array) = require(user @? { id }, "User with id %b does not exist".format(id));

function init_canvas() {
    val canvas_size = create size (
        width = 2000,
        height = 2000
    );

    if (not exists(canvas @? { })) {
        create canvas (
            size = canvas_size,
            pixelSize = 20,
            minScale = 10,
            maxScale = 50,
            defaultColor = "0xffffff"
        );
    }
}

function set_canvas_zoomScale(minScale: decimal, maxScale: decimal) {
    val canvas = canvas @* { } limit 1;
    update canvas ( .minScale = minScale, .maxScale = maxScale );
}
</string>
                            </entry>
                            <entry key="canvas/model.rell">
                                <string>entity cell {
    key location: location;
    mutable color: text;
    mutable paintedBy: user;
    mutable paintedAt: timestamp;
    mutable dirty: boolean;
}

entity canvas {
    mutable size: size;
    mutable pixelSize: integer;
    mutable minScale: decimal;
    mutable maxScale: decimal;
    mutable defaultColor: text;
}

entity location {
    x: integer;
    y: integer;
}

entity size {
    width: integer;
    height: integer;
}

struct cell_dto {
    location: struct&lt;location&gt;;
    color: text;
    paintedBy: struct&lt;user&gt;;
    paintedAt: timestamp;
    dirty: boolean;
}

struct location_dto {
    location: struct&lt;location&gt;;
}

struct cells_dto {
    cells: set&lt;cell&gt;;
}

struct canvas_dto {
    size: struct&lt;size&gt;;
    pixelSize: integer;
    minScale: decimal;
    maxScale: decimal;
    defaultColor: text;
}
</string>
                            </entry>
                            <entry key="canvas/module.rell">
                                <string>module;

import lib.ft4.auth;
import lib.ft4.ft4_basic_dev.*;
import wallet.*;
import accounts.*;
import leaderboards.*;

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
  flags = ["MySession"]
);</string>
                            </entry>
                            <entry key="canvas/operations.rell">
                                <string>operation paint_cell(x: integer, y: integer, at_color: text) {
    val account = auth.authenticate();
    val user = user @ { account };
    val timestamp = op_context.last_block_time;

    val balance = check_balance(account);

    require(balance.amount &gt;= 1, "Not enough balance to paint");

    if (not exists(cell @? { .location.x == x, .location.y == y })) {
        val new_loc = create location (
            x = x,
            y = y
        );

        create cell (
            location = new_loc,
            color = at_color,
            paintedBy = user,
            paintedAt = timestamp,
            dirty = true
        );

        val auth_desc = create_auth_descriptor(ft4.admin.get_admin_pubkey());
        val admin_account = ft4.accounts.account_by_id(auth_desc.hash());
        transfer_to(account, admin_account, 1);
        update_lb_participant(LeaderboardType.TOPPAINTEDCELLS, user);
    } else {
        update cell @ {
            .location.x == x,
            .location.y == y
        } (
            color = at_color,
            paintedBy = user,
            paintedAt = timestamp,
            dirty = true
        );

        val auth_desc = create_auth_descriptor(ft4.admin.get_admin_pubkey());
        val admin_account = ft4.accounts.account_by_id(auth_desc.hash());
        transfer_to(account, admin_account, 1);
        update_lb_participant(LeaderboardType.TOPPAINTEDCELLS, user);
    }
}
</string>
                            </entry>
                            <entry key="canvas/queries.rell">
                                <string>query get_all_cells(user_id: byte_array) {
    val cells = cell @* { } ( cell_dto(.location.to_struct(), .paintedAt, .paintedBy.to_struct(), .color, .dirty) );
    return cells;
}

query get_canvas(user_id: byte_array) {
    val canvas = canvas @ { } ( canvas_dto(.size.to_struct(), .pixelSize, .minScale, .maxScale, .defaultColor) );
    return canvas;
}

query get_cells_by_user(account_id: byte_array) {
    val user = user @ { .id == account_id };
    val cells = cell @* { .paintedBy == user } ( cell_dto(.location.to_struct(), .paintedAt, .paintedBy.to_struct(), .color, .dirty) );
    return cells;
}

</string>
                            </entry>
                            <entry key="development.rell">
                                <string>module;

import main;
import test.test_operations.*;
import canvas.*;
import voting.*;</string>
                            </entry>
                            <entry key="leaderboards/admin/module.rell">
                                <string>@mount("admin.leaderboards")
module;

import ^.*;</string>
                            </entry>
                            <entry key="leaderboards/admin/operations.rell">
                                <string>operation create_leaderboard(type: LeaderboardType, durationDays: integer) {
    ft4.admin.require_admin();
    generate_lb(type, durationDays);
}
</string>
                            </entry>
                            <entry key="leaderboards/functions.rell">
                                <string>function generate_lb(type: LeaderboardType, durationDays: integer) {
    val lb = leaderboard @? {
        .type == type,
        .created &lt;= time.now(),
        .expired &gt; time.now()
    };

    if (empty(lb)) {
        create_lb(type, durationDays);
    } else {
        require(false, "Active leaderboard already exists for that type");
    }
}

function create_lb(type: LeaderboardType, durationDays: integer) {
    create leaderboard (
        type,
        .created = time.now(),
        .expired = time.days_from_now(durationDays)
    );
}

function get_lb_participants(type: LeaderboardType, page_size: integer) {
    val lb = leaderboard @? {
        .type == type,
        .created &lt;= time.now(),
        .expired &gt; time.now()
    };

    if (empty(lb)) {
        return null;
    } else {
        return leaderboard_participant @* {
            .leaderboard == lb
        } (
            leaderboard_participant_dto(.leaderboard.to_struct(), .user.to_struct(), .score)
        ) limit page_size;
    }
}

function get_active_lbs() {
    return leaderboard @* {
        .created &lt;= time.now(),
        .expired &gt; time.now()
    } ( leaderboard_dto(.type, .created, .expired) );
}

function update_lb_participant(type: LeaderboardType, user: user) {
    val lb = leaderboard @? {
        .type == type,
        .created &lt;= time.now(),
        .expired &gt; time.now()
    };

    if (not empty(lb)) {
        val participant = leaderboard_participant @? {
            .leaderboard == lb,
            .user == user
        };

        if (empty(participant)) {
            create leaderboard_participant (
                .leaderboard = lb,
                .user = user,
                .score = 1
            );
        } else {
            update leaderboard_participant @ { lb, user } (
                .score += 1
            );
        }
    }
}
</string>
                            </entry>
                            <entry key="leaderboards/model.rell">
                                <string>entity leaderboard {
    key type: LeaderboardType;
    created: timestamp;
    expired: timestamp;
}

entity leaderboard_participant {
    key leaderboard: leaderboard, user: user;
    mutable score: integer;
}

enum LeaderboardType {
    TOPVOTED,
    TOPPAINTEDCELLS
}

struct leaderboard_dto {
    type: LeaderboardType;
    created: timestamp;
    expired: timestamp;
}

struct leaderboard_participant_dto {
    leaderboard: struct&lt;leaderboard&gt;;
    user: struct&lt;user&gt;;
    score: integer;
}
</string>
                            </entry>
                            <entry key="leaderboards/module.rell">
                                <string>module;

import accounts.*;
import rell_modules.time;</string>
                            </entry>
                            <entry key="leaderboards/queries.rell">
                                <string>query get_leaderboard_participants(type: LeaderboardType, page_size: integer) {
    require(page_size &lt;= 100, "page_size must be less than or equal to 100");
    return get_lb_participants(type, page_size);
}

query get_all_leaderboard_participants(page_size: integer) {
    require(page_size &lt;= 100, "page_size must be less than or equal to 100");
    return [
        get_lb_participants(
            LeaderboardType
                .TOPVOTED,
            page_size
        ),
        get_lb_participants(
            LeaderboardType
                .TOPPAINTEDCELLS,
            page_size
        )
    ];
}

query get_active_leaderboards() {
    return get_active_lbs();
}
</string>
                            </entry>
                            <entry key="lib/ft4/accounts/auth_basic.rell">
                                <string>
struct single_sig_args {
    flags: set&lt;text&gt;;
    pubkey;
}

struct multi_sig_args {
    flags: set&lt;text&gt;;
    signatures_required: integer;
    pubkeys: list&lt;pubkey&gt;;
}

/*
 * Returns VALID if valid.
 */
function check_single_sig_auth(args: byte_array, participants: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): utils.validation_result {
    if(participants.size() &gt; 1) {
        return utils.invalid("Single sig Auth Descriptor must have only one participant.");
    }
    if (participants.size() &lt; 1) {
        return utils.invalid("Single sig Auth Descriptor's participant list is empty.");
    }

    val ss_args = single_sig_args.from_bytes(args);
    if ( check_required_flags(ss_args.flags, required_flags)) {
        if (op_context.is_signer(participants[0])) {
            return utils.VALID;
        } else {
            return utils.invalid("The participant is not the signer of this transaction.");
        }
    } else {
        return utils.invalid("Some required flags " + required_flags.to_text() + " are missing on the (single sig) Auth Descriptor.");
    }
}

/*
 * Returns VALID if valid.
 */
function check_multi_sig_auth(args: byte_array, participants: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): utils.validation_result {
    val multi_sign_args = multi_sig_args.from_bytes(args);
    if (not (check_required_flags(multi_sign_args.flags, required_flags))) {
       return utils.invalid("Some required flags " + required_flags.to_text() + " are missing on the (multi sig) Auth Descriptor.");
    }
    var num_sign = multi_sign_args.signatures_required;
    for(s in participants) {
        if(op_context.is_signer(s)) {
            num_sign -= 1;
            if(num_sign &lt; 1) {
                return utils.VALID;
            }
        }
    }
    return utils.invalid("Transaction must be signed by at least " + multi_sign_args.signatures_required + " participants in the Auth Descriptor.");
}

/*
 * Returns false if any of the required flags are missing from the "flags" set.
 */
function check_required_flags(flags: set&lt;text&gt;, required_flags: list&lt;text&gt;): boolean {
    return flags.contains_all(required_flags);
}

/*
 * Returns the set of flags found in the "args" parameter.
 */
function get_flags_from_args(a_t: auth_type, args: byte_array): set&lt;text&gt; {
    when (a_t) {
        S -&gt; {
            return single_sig_args.from_bytes(args).flags;
        }
        M -&gt; {
            return multi_sig_args.from_bytes(args).flags;
        }
        else -&gt; {
            val f = set&lt;text&gt;();
            return f;
        }
    }
}

/*
 * Returns VALID if authentication arguments are valid.
 */
function check_auth_args(a_t: auth_type, args: byte_array, participants: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): utils.validation_result {
    return when (a_t) {
        S -&gt; check_single_sig_auth(args, participants, required_flags);
        M -&gt; check_multi_sig_auth(args, participants, required_flags);
        else -&gt; utils.invalid("Don't recognize authentication type (S or M).");
    };
}

/*
 * Will:
 * 1. Explode if any expiry rule is broken.
 * 2. Explode if required flags are missing on the Auth Desc.
 * 3. Update the expiry rule values.
 * 4. Clean away expired Auth Descs on the account.
 */
function require_auth(account, account_auth_descriptor, required_flags: list&lt;text&gt;) {
	require(is_valid(account_auth_descriptor), "Invalid Auth Descriptor structure.");

	val result: utils.validation_result = check_auth_args(
       		account_auth_descriptor.auth_type,
       		account_auth_descriptor.args,
            get_participants(account_auth_descriptor.auth_type, account_auth_descriptor.args),
       		//auth_descriptor_participant @* { account_auth_descriptor } ( .id ),
       		required_flags
	);

    require(result.valid, result.error!!); // Prints a precise error message.

    update_auth_descriptor_rule_variables(account_auth_descriptor);
    delete_expired_auth_descriptors(account);
}

function get_participants(a_t: auth_type, args: byte_array): list&lt;byte_array&gt;{
    var participants: list&lt;byte_array&gt;? = null;
    if (a_t == auth_type.S or a_t == auth_type.ES){
        participants = [single_sig_args.from_bytes(args).pubkey];
    }
    if (a_t == auth_type.M or a_t == auth_type.EM) {
        participants = multi_sig_args.from_bytes(args).pubkeys;
    }
    //TODO: add extendable callback for custom types
    return require(participants, "Unknown auth_descriptor type"); // or return empty list?
}

</string>
                            </entry>
                            <entry key="lib/ft4/accounts/auth_descriptor_rule.rell">
                                <string>
enum rule_variable {
	block_height,
	block_time,
	op_count
}

enum rule_operator {
	lt,
	le,
	eq,
	ge,
	gt
}

struct rule_expression {
	variable: text;
	operator: text;
	value: gtv;
}

entity auth_descriptor_rule_variable {
	key account_auth_descriptor, name;
	mutable value: byte_array;
}

function is_valid(auth_descriptor: account_auth_descriptor): boolean {
	if (auth_descriptor.rules == null.to_gtv().to_bytes()) {
		return true;
	}
	
	return is_rule_valid(
		gtv.from_bytes(auth_descriptor.rules), 
		load_variables(auth_descriptor)
	);
}

function is_rule_valid(rule: gtv, variables: map&lt;text, gtv&gt;): boolean {
	val parameters = list&lt;gtv&gt;.from_gtv(rule);
	val operator = text.from_gtv(parameters[1]);
	
	if (operator == "and") {
		return handle_composed_rule(rule, variables);
	} else {
		return handle_single_rule(rule, variables);
	}
}

function handle_single_rule(rule: gtv, variables: map&lt;text, gtv&gt;): boolean {
	return evaluate_int_variable_rule(
		rule_expression.from_gtv(rule), 
		variables
	);	
}

 
function handle_composed_rule(rule: gtv, variables: map&lt;text, gtv&gt;): boolean {
	val parameters = list&lt;gtv&gt;.from_gtv(rule);
	val operator = text.from_gtv(parameters[1]);
	if (operator == "and") {
		return is_rule_valid(parameters[0], variables) and is_rule_valid(parameters[2], variables);
	} else {
		return false;
	}
}

function is_active(account_auth_descriptor): boolean {
	if (account_auth_descriptor.rules == null.to_gtv().to_bytes()) { 
		return true;
	}
	
	return is_rule_active(gtv.from_bytes(account_auth_descriptor.rules), map&lt;text, gtv&gt;());
}


function is_rule_active(r: gtv, variables: map&lt;text, gtv&gt;): boolean {
	val parameters = list&lt;gtv&gt;.from_gtv(r);
	val operator = text.from_gtv(parameters[1]);
	when (operator) {
		"and" -&gt; {
			return is_rule_active(parameters[0], variables) and is_rule_active(parameters[2], variables);
		}
		else -&gt; {
			return is_simple_rule_active(r, variables);
		}
	}
}

function is_simple_rule_active(rule: gtv, variables: map&lt;text, gtv&gt;): boolean {
	val parameters = list&lt;gtv&gt;.from_gtv(rule);
	val variable_name = text.from_gtv(parameters[0]);
	when (rule_variable.value(variable_name)) {
		rule_variable.block_height -&gt; {
			return is_block_height_rule_active(rule);
		}
		rule_variable.block_time -&gt; {
			return is_block_time_rule_active(rule);
		}		
		rule_variable.op_count -&gt; {
			return is_op_count_rule_active(rule);
		}
	}
}

/*
 *  Variables
 */

function evaluate_int_variable_rule(rule: rule_expression, variables: map&lt;text, gtv&gt;): boolean {
	val variable = rule_variable.value(rule.variable);
	val operator = rule_operator.value(rule.operator);
	val current_value = variable_value(variable, variables);
	val defined_value = integer.from_gtv(rule.value);

	when (operator) {
		rule_operator.lt -&gt; {
			return current_value &lt; defined_value;
		}
		rule_operator.le -&gt; {
			return current_value &lt;= defined_value;
		}
		rule_operator.eq -&gt; {
			return current_value == defined_value;
		}
		rule_operator.ge -&gt; {
			return current_value &gt;= defined_value;
		}
		rule_operator.gt -&gt; {
			return current_value &gt; defined_value;
		}
	}
}


/*
 * Called from _add_auth_descriptor function
 */
function setup_auth_descriptor_variables(account_auth_descriptor) {
	
	if (account_auth_descriptor.rules == null.to_gtv().to_bytes()) {
		return;
	} 
	
	val variables = get_variable_names_set(gtv.from_bytes(account_auth_descriptor.rules));
	
	for (variable in variables) {
		when (variable) {
			rule_variable.op_count.name -&gt; {
				create auth_descriptor_rule_variable(
					account_auth_descriptor,
					name = variable,
					value = op_count_variable_initial_value().to_bytes()
				);
			}
		}
	}
}
 
function update_variables(account_auth_descriptor, variables: map&lt;text, gtv&gt;) {
	for ((name, value) in variables) {
		val variable = require(
			auth_descriptor_rule_variable @? { account_auth_descriptor, name },
			"No auth descriptor variable found: %s, %s".format(name, integer.from_gtv(value))
			);
		val int_value = integer.from_gtv(value);
		
		when (name) {
			rule_variable.op_count.name -&gt; {
				variable.value = (int_value + 1).to_gtv().to_bytes();
			}
		}
	}
}
 
function variable_value(variable: rule_variable, variables: map&lt;text, gtv&gt;): integer {
	when (variable) {
		rule_variable.block_height -&gt; {
			return op_context.block_height;
		}
		rule_variable.block_time -&gt; {
			return op_context.last_block_time;
		}
		rule_variable.op_count -&gt; {
			return integer.from_gtv(variables[rule_variable.op_count.name]);
		}
	}
}

/*
 * Analyze the rules before assigning them to an authenticator descriptor
 */
 function analyze_auth_descriptor_rules(rules: gtv, hop: integer) {
 	require(hop&lt;3, "Too many rules");
 	if (rules == null.to_gtv()) {
		return;
	}
	
 	val params = list&lt;gtv&gt;.from_gtv(rules);
 	require(params.size() &lt;=3, "Too many params");
 	
 	val operator = text.from_gtv(params[1]);
 	if(operator == "and") {
 		analyze_auth_descriptor_rules(params[0], hop+1); 
 		analyze_auth_descriptor_rules(params[2], hop+1);
 	} 	
 	
	return;
 }

/*
 * Returns set of variable names used in a rule
 */
function get_variable_names_set(rules: gtv): set&lt;text&gt; {
	val parameters = list&lt;gtv&gt;.from_gtv(rules);
	val operator = text.from_gtv(parameters[1]);
	var vars = set&lt;text&gt;();
	if (operator == "and") {
		vars.add_all(get_variable_names_set(parameters[0]));
		vars.add_all(get_variable_names_set(parameters[2]));
	} else {
		vars.add(text.from_gtv(parameters[0]));
	}
	return vars;
} 

function load_variables(account_auth_descriptor): map&lt;text, gtv&gt; {
	val variables = auth_descriptor_rule_variable @* { account_auth_descriptor };
	
	val variables_map = map&lt;text, gtv&gt;();
	for (variable in variables) {
		variables_map[variable.name] = gtv.from_bytes(variable.value);
	}
	
	return variables_map;
}

function update_auth_descriptor_rule_variables(account_auth_descriptor) {
	val variables = load_variables(account_auth_descriptor);
	update_variables(account_auth_descriptor, variables);
}

/*
 * auth descriptor cleanup
 */

function delete_expired_auth_descriptors(account) {
	val auth_descriptors = account_auth_descriptor @* { account };
	
	for (auth_descriptor in auth_descriptors) {
		if (is_active(auth_descriptor) and not is_valid(auth_descriptor)) {
			_delete_auth_descriptor(auth_descriptor);
		}
	}
}

/****************************************************************************************
 *                                     block_time                                       *
 ****************************************************************************************/

function is_block_time_rule_active(r: gtv): boolean {
	val parameters = list&lt;gtv&gt;.from_gtv(r);
	val operator = rule_operator.value(text.from_gtv(parameters[1]));
	val value = integer.from_gtv(parameters[2]);
	when (operator) {
		rule_operator.gt -&gt; {
			return op_context.last_block_time &gt; value;
		}
		rule_operator.ge,
		rule_operator.eq -&gt; {
			return op_context.last_block_time &gt;= value;
		}
		else -&gt; {
			return true;
		}
	}
}


/****************************************************************************************
 *                                  block_height                                        *
 ****************************************************************************************/

function is_block_height_rule_active(r: gtv): boolean {
	val parameters = list&lt;gtv&gt;.from_gtv(r);
	val operator = rule_operator.value(text.from_gtv(parameters[1]));
	val value = integer.from_gtv(parameters[2]);
	when (operator) {
		rule_operator.gt -&gt; {
			return op_context.block_height &gt; value;
		}
		rule_operator.ge,
		rule_operator.eq -&gt; {
			return op_context.block_height &gt;= value;
		}
		else -&gt; {
			return true;
		}
	}
}


/****************************************************************************************
 *                                     op_count                                         *
 ****************************************************************************************/
 
 function op_count_variable_initial_value(): gtv {
 	return (1).to_gtv();
 }
 
 function is_op_count_rule_active(rule: gtv): boolean {
 	return true;
 }
</string>
                            </entry>
                            <entry key="lib/ft4/accounts/auth_external.rell">
                                <string>
struct eth_auth_args {
    account;
    account_auth_descriptor;
    signatures: list&lt;auth.signature&gt;;
}

function AuthDescriptor(id: byte_array) = require(
    account_auth_descriptor @? { id },
    "Provided auth descriptor id does not exist %s".format(id)
);

function Account(id: byte_array) = require(
    account @? { id },
    "Account not found: %s".format(id)
);
</string>
                            </entry>
                            <entry key="lib/ft4/accounts/external/module.rell">
                                <string>@mount('ft4')
module;

import ^^.accounts;
import ^^.assets;
import ^^.auth;
import ^^.utils;
</string>
                            </entry>
                            <entry key="lib/ft4/accounts/external/operations.rell">
                                <string>
function delete_auth_descriptor_message(gtv) {
    val params = struct&lt;delete_auth_descriptor&gt;.from_gtv(gtv);
    return "Please sign the message\nto delete auth descriptor:\n%s\n\nfrom account\n{account_id}".format(params.auth_descriptor_id);
}

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
    scope = "ft4.delete_auth_descriptor",
    flags = ["A"],
    message = delete_auth_descriptor_message(*)
);

operation delete_auth_descriptor(auth_descriptor_id: byte_array) {
    // val flags = if (auth_descriptor_id == delete_descriptor_id) list&lt;text&gt;() else ["A"];
    val account = auth.authenticate();

    accounts._delete_auth_descriptor(
        accounts.auth_descriptor_by_id(account, auth_descriptor_id)
    );    
}

function delete_all_auth_descriptors_exclude_message(gtv) {
    val params = struct&lt;delete_all_auth_descriptors_exclude&gt;.from_gtv(gtv);
    return "Please sign the message\nto delete all auth descriptors excluding:\n%s\n\n from account:\n{account_id}".format(params.auth_descriptor_id);
}

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
    scope = "ft4.delete_all_auth_descriptors_exclude",
    flags = ["A"],
    message = delete_all_auth_descriptors_exclude_message(*)
);

operation delete_all_auth_descriptors_exclude(account_id: byte_array, auth_descriptor_id: byte_array) {
    val account =  accounts.account_by_id(account_id);
    val auth_descriptor = accounts.auth_descriptor_by_id(account, auth_descriptor_id);
    accounts._auth(account, auth_descriptor, ["A"]);

    accounts._delete_all_auth_descriptors_exclude(auth_descriptor);
}

function add_auth_descriptor_message(gtv) {
    val params = struct&lt;add_auth_descriptor&gt;.from_gtv(gtv);
    val flags = params.new_desc.args[0];

    return "Please sign the message\nto add auth descriptor\nwith flags:\n%s\n\nto account:\n{account_id}".format(flags);
}

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
    scope = "ft4.add_auth_descriptor",
    flags = ["A"],
    message = add_auth_descriptor_message(*)
);

operation add_auth_descriptor(new_desc: accounts.auth_descriptor) {
    val account = auth.authenticate();
    accounts.add_auth_descriptor_to_account(account, new_desc);
}
</string>
                            </entry>
                            <entry key="lib/ft4/accounts/external/queries.rell">
                                <string>
query get_config() {
    return (
        rate_limit = accounts.get_rate_limit_config()
    );
}

query get_account_rate_limit_last_update(account_id: byte_array) {
    if (accounts.get_rate_limit_config().active == false) return (points = 0, last_update = 0);
    
    return accounts.rl_state @ { .account.id == account_id }
    (
        .points, 
        .last_update
    );
}

query is_auth_descriptor_valid(account_id: byte_array, auth_descriptor_id: byte_array) {
    return accounts.is_valid(accounts.account_auth_descriptor @ {
        .account.id == account_id,
        .id == auth_descriptor_id
    });
}

query _get_account_auth_descriptors(id: byte_array) {
    return accounts.account_auth_descriptor @* {
        .account.id == id
    } ( accounts.get_auth_descriptor_data($) );
}

query get_account_auth_descriptors(id: byte_array, page_size: integer, page_cursor: text?) {
    return utils.make_page(
        accounts.get_paginated_auth_descriptors(id, page_size, page_cursor), 
        page_size
    );
}

query get_account_auth_descriptors_by_participant_id(account_id: byte_array, participant_id: byte_array) {
    return (ad: accounts.account_auth_descriptor, p: accounts.auth_descriptor_participant) @* {
        ad.account.id == account_id,
        p.id == participant_id,
        ad == p.account_auth_descriptor
    } (
        accounts.get_auth_descriptor_data(ad)
    );
}

query get_account_by_id(id: byte_array) {
    return accounts.account @? { id } ( .id );
}

query get_account_by_auth_descriptor(accounts.auth_descriptor) {
    return accounts.account @? { .id == auth_descriptor.hash() } ( .id );
}

query get_accounts_by_participant_id(id: byte_array) {
    return accounts.auth_descriptor_participant @* { id } ( .account_auth_descriptor.account.id );
}

query _get_accounts_by_auth_descriptor_id(id: byte_array) {
    return accounts.account_auth_descriptor @* { id } ( .account.id );
}

query get_accounts_by_auth_descriptor_id(id: byte_array, page_size: integer, page_cursor: text?) {
    return utils.make_page(
        accounts.get_paginated_accounts_by_ad_id(id, page_size, page_cursor),
        page_size
    );
}

query get_auth_descriptor_nonce(
    account_id: byte_array, 
    auth_descriptor_id: byte_array
) = accounts.account_auth_descriptor @ { 
        .account.id == account_id, 
        .id == auth_descriptor_id 
    } ( .ctr );
</string>
                            </entry>
                            <entry key="lib/ft4/accounts/module.rell">
                                <string>@mount('ft')
module;

struct module_args {
	rate_limit_active: boolean;
	rate_limit_max_points: integer;
    rate_limit_recovery_time: integer;
    rate_limit_points_at_account_creation: integer;    
}

import ^.auth;
import ^.utils;
import ^.version;
import .external;

enum auth_type {
    S, M, ES, EM,
}

struct auth_descriptor {
    auth_type;
    args: list&lt;gtv&gt;;
    rules: gtv;
}

entity account {
    key id: byte_array;
}

entity account_meta {
    meta_key: text;
    value: byte_array;
    index account, meta_key;
    index meta_key, value;
}

entity account_auth_descriptor {
    id: byte_array;
    key account, id;
    index id;
    auth_type;
    args: byte_array;
    rules: byte_array;
    mutable ctr: integer;
    created: timestamp;
}

entity auth_descriptor_participant {
    key account_auth_descriptor, id: byte_array;
}

// rate limiter
entity rl_state {
    key account;
    mutable points: integer;
    mutable last_update: timestamp;
    mutable max_points: integer;
    mutable recovery_time: timestamp;
}


function add_auth_descriptor_to_account(account, auth_descriptor): byte_array {
    val id = auth_descriptor.hash();

    validate_auth_descriptor_args(auth_descriptor);
    analyze_auth_descriptor_rules(auth_descriptor.rules, 0);

    val account_auth_descriptor = create account_auth_descriptor (
        account, id,
        auth_descriptor.auth_type,
        args = auth_descriptor.args.to_gtv().to_bytes(),
        rules = auth_descriptor.rules.to_gtv().to_bytes(),
        created = op_context.last_block_time,
        ctr = 0
    );

    _add_auth_participant(account, auth_descriptor, account_auth_descriptor);

    setup_auth_descriptor_variables(account_auth_descriptor);
    return id;
}

function _delete_auth_descriptor(auth_descriptor: account_auth_descriptor) {
    require(auth_descriptor.account.id != auth_descriptor.id, "Can't delete initial auth descriptor");
    delete auth_descriptor_rule_variable @* { auth_descriptor };
    delete auth_descriptor_participant @* { auth_descriptor };
    delete auth_descriptor;
}

function _delete_all_auth_descriptors_exclude(auth_descriptor: account_auth_descriptor) {
    delete (adrv: auth_descriptor_rule_variable, ad: account_auth_descriptor) @* {
        ad.account == auth_descriptor.account,
        ad.id != auth_descriptor.account.id,
        ad.id != auth_descriptor.id,
        adrv.account_auth_descriptor == ad    
    };
    delete (adp: auth_descriptor_participant, ad: account_auth_descriptor) @* {
        ad.account == auth_descriptor.account,
        ad.id != auth_descriptor.account.id,
        ad.id != auth_descriptor.id,
        adp.account_auth_descriptor == ad
    };
    delete account_auth_descriptor @* {
       .account == auth_descriptor.account,
       .id != auth_descriptor.account.id,
       .id != auth_descriptor.id
    };
}

function create_account_with_auth(auth_descriptor): byte_array {
    require(auth_descriptor.rules == null.to_gtv(), "Cannot create an account with a restricted auth descriptor");
    
    val id = auth_descriptor.hash();
    val acc = create account (id);

    add_auth_descriptor_to_account(acc, auth_descriptor);

    val max_points = chain_context.args.rate_limit_max_points;
    val recovery_time = chain_context.args.rate_limit_recovery_time;
    val points_at_start = chain_context.args.rate_limit_points_at_account_creation;
    
    create rl_state(acc, .points = points_at_start, .last_update = op_context.last_block_time, max_points, recovery_time);
    
    return id;
}

function _add_auth_participant(account, auth_descriptor, account_auth_descriptor) {
    val participants = get_participants(auth_descriptor.auth_type, auth_descriptor.args.to_gtv().to_bytes());
    require(op_context.get_signers().size() &gt;= participants.size(), "Too few transaction signers");
    for (participant in participants) {
        require(op_context.is_signer(participant), "One participant in the Auth Desc didn't sign this transaction.");
        create auth_descriptor_participant(account_auth_descriptor, id = participant);
    }
}

function _add_eth_auth_participant(account, auth_descriptor, account_auth_descriptor) {
    for (participant in get_participants(auth_descriptor.auth_type, auth_descriptor.args.to_gtv().to_bytes())) {
        create auth_descriptor_participant(account_auth_descriptor, id = participant);
    }
}

function _auth(account: account, auth_descriptor: account_auth_descriptor, required_flags: list&lt;text&gt;) {
    rate_limit(account);
    require_auth(account, auth_descriptor, required_flags);
}

function auth_descriptor_by_id(account, id: byte_array) = require(
    account_auth_descriptor @? { account, id },
    "Auth descriptor '%s' not found for account '%s'".format(id, account.id)
);

function account_by_id(id: byte_array) = require(
    account @? { id },
    "Account not found: '%s'".format(id)
);

function single_sig_auth_descriptor(pubkey, flags: set&lt;text&gt;) = auth_descriptor(
    auth_type = auth_type.S,
    args = [
        flags.to_gtv(),
        pubkey.to_gtv()
    ],
    null.to_gtv()
);

function get_paginated_auth_descriptors(id: byte_array, page_size: integer, page_cursor: text?) {
    val before_rowid = utils.before_rowid(page_cursor);
    return account_auth_descriptor @* {
        .account.id == id,
        .rowid &gt; (before_rowid ?: rowid(0))
    } (
        utils.pagination_result(
            data = get_auth_descriptor_data($).to_gtv_pretty(),
            rowid = .rowid
        )
    ) limit utils.fetch_data_size(page_size);
}

function get_auth_descriptor_data(ad: account_auth_descriptor) {
    return (
        id = ad.id,
        auth_type = ad.auth_type,
        args = gtv.from_bytes(ad.args),
        rules = gtv.from_bytes(ad.rules),
        created = ad.created
    );
}

function get_paginated_accounts_by_ad_id(id: byte_array, page_size: integer, page_cursor: text?) {
    val before_rowid = utils.before_rowid(page_cursor);
    return account_auth_descriptor @* {
        .id == id,
        .rowid &gt; (before_rowid ?: rowid(0))
    } (
        utils.pagination_result(
            data=.account.id.to_gtv_pretty(),
            rowid=.rowid
        )
    ) limit utils.fetch_data_size(page_size);
}

function validate_auth_descriptor_args(auth_descriptor) {
    when (auth_descriptor.auth_type) {
        S, ES -&gt; single_sig_args.from_gtv(auth_descriptor.args.to_gtv());
        M, EM -&gt; multi_sig_args.from_gtv(auth_descriptor.args.to_gtv());
    }
}

namespace Unsafe {
    //WARNING: doesn't check that the account is being created by the owner(s)
    function create_account_with_auth(auth_descriptor): byte_array {
        require(auth_descriptor.rules == null.to_gtv(), "Cannot create an account with a restricted auth descriptor");
        val id = auth_descriptor.hash();
        val acc = create account (id);
        _add_auth_descriptor(
            acc, auth_descriptor
        );
        val max_points = chain_context.args.rate_limit_max_points;
        val recovery_time = chain_context.args.rate_limit_recovery_time;
        val points_at_start = chain_context.args.rate_limit_points_at_account_creation;
        
        create rl_state(acc, .points = points_at_start, .last_update = op_context.last_block_time, max_points, recovery_time);
        
        return id;
    }

    //WARNING: doesn't check that the auth_descriptor is being added by the participant(s) nor owner(s)
    function _add_auth_descriptor(account, auth_descriptor): byte_array {
        val id = auth_descriptor.hash();
        
        validate_auth_descriptor_args(auth_descriptor);
        analyze_auth_descriptor_rules(auth_descriptor.rules, 0);
        
        val account_auth_descriptor = create account_auth_descriptor (
            account, id,
            auth_descriptor.auth_type,
            args = auth_descriptor.args.to_gtv().to_bytes(),
            rules = auth_descriptor.rules.to_gtv().to_bytes(),
            created = op_context.last_block_time,
            ctr = 0
        );
        
        for (participant in get_participants(auth_descriptor.auth_type, auth_descriptor.args.to_gtv().to_bytes())) {
            create auth_descriptor_participant(account_auth_descriptor, id = participant);
        }
        
        setup_auth_descriptor_variables(account_auth_descriptor);
        return id;
    }
}
</string>
                            </entry>
                            <entry key="lib/ft4/accounts/rate_limit.rell">
                                <string>function rate_limit(account) {
    if (chain_context.args.rate_limit_active == false) return;
    
    val max_counter = chain_context.args.rate_limit_max_points;
    val recovery_time = chain_context.args.rate_limit_recovery_time;
    val stat = require(
        rl_state@?{account} (.points, .last_update), 
        "Rate limiter state not found for the account with ID: %s".format(account.id)
    );
    val delta = op_context.last_block_time - stat.last_update;
    var got_points = 0;
    var update_time = stat.last_update;

    if (delta &gt; recovery_time) {
        got_points = delta / recovery_time;
        update_time = stat.last_update + got_points * recovery_time;
        if (got_points + stat.points &gt; max_counter) {
            got_points = max_counter - stat.points;
            // if user is at maximum reset his 
            // timer
            update_time = op_context.last_block_time;
        }
    }
    
    require(stat.points + got_points &gt; 0, "Insufficient rate limiter points");
    
    update rl_state @ { account } (
        .points += got_points - 1,
        .last_update = update_time
    );
}

function add_rate_limit_points(account, amount: integer) {
    var state = require(
        rl_state@?{account}, 
        "Rate limiter state not found for the account with ID: %s".format(account.id)
    );
	state.points += amount;
}

function get_rate_limit_config() {
    return (
        active = chain_context.args.rate_limit_active,
        max_points = chain_context.args.rate_limit_max_points,
        recovery_time = chain_context.args.rate_limit_recovery_time,
        points_at_account_creation = chain_context.args.rate_limit_points_at_account_creation
    );
}</string>
                            </entry>
                            <entry key="lib/ft4/admin/module.rell">
                                <string>@mount("ft4.admin")
module;

import ^.accounts;
import ^.assets;
import ^.utils;
import ^.version;

struct module_args {
    admin_pubkey: pubkey;
}

function require_admin() {
    require(
        op_context.is_signer(chain_context.args.admin_pubkey),
        "Expected admin signature"
    );
}

function get_admin_pubkey() {
    return chain_context.args.admin_pubkey;
}
</string>
                            </entry>
                            <entry key="lib/ft4/admin/operations.rell">
                                <string>
operation register_account(accounts.auth_descriptor) {
    require_admin();
    accounts.Unsafe.create_account_with_auth(auth_descriptor);
}

operation register_asset(name, symbol: text, decimals: integer, icon_url: text) {
    require_admin();
    assets.Unsafe.register_asset(name, symbol, decimals, chain_context.blockchain_rid, icon_url);
}

operation mint(account_id: byte_array, asset_id: byte_array, amount: big_integer) {
    require_admin();
    assets.Unsafe.mint(accounts.Account(account_id), assets.Asset(asset_id), amount);
}

operation add_rate_limit_points(account_id: byte_array, amount: integer) {
    require_admin();
	accounts.add_rate_limit_points(accounts.Account(account_id), amount);
}

</string>
                            </entry>
                            <entry key="lib/ft4/assets/asset.rell">
                                <string>
entity asset {
    key id: byte_array;
    name;
    key symbol: text;
    decimals: integer;
    issuing_brid: byte_array;
    icon_url: text;
    mutable total_supply: big_integer;
}

function Asset(id: byte_array) = require(
    asset @? { id },
    "Asset &lt;%s&gt; not found".format(id)
);

entity balance {
    key accounts.account, asset;
    mutable amount: big_integer = 0L;
}

val max_asset_amount = big_integer.from_hex("ff".repeat(32));

function ensure_balance(accounts.account, asset): balance {
    val balance = balance @? {asset, account};
    if (balance != null) {
       return balance;
    }
    else return create balance(account, asset, amount = 0L);
}

function map_asset(asset: asset) {
    return (
        id = asset.id,
        name = asset.name,
        symbol = asset.symbol,
        decimals = asset.decimals,
        brid = asset.issuing_brid,
        icon_url = asset.icon_url,
        supply = asset.total_supply
    );
}

function get_paginated_asset_balances(account_id: byte_array, page_size: integer, page_cursor: text?): list&lt;utils.pagination_result&gt; {
    val before_rowid = utils.before_rowid(page_cursor);
    return balance @* {
        .account.id == account_id,
        .rowid &gt; (before_rowid ?: rowid(0))
    } (
        utils.pagination_result(
            data = (
                asset = map_asset(.asset),
                amount = .amount
            ).to_gtv_pretty(),
            rowid = .rowid
        )
    ) limit utils.fetch_data_size(page_size);
}

function get_all_assets(page_size: integer, page_cursor: text?) {
    val before_rowid = utils.before_rowid(page_cursor);
    return assets.asset @* {
        .rowid &gt; (before_rowid ?: rowid(0))
    } (
        utils.pagination_result(
            data = (map_asset($)).to_gtv_pretty(),
            rowid = .rowid
        )
    ) limit utils.fetch_data_size(page_size);
}

function get_asset_balances(account_id: byte_array) {
    return balance @* { .account.id == account_id } (
        asset = map_asset(.asset),
        amount = .amount
    );
}

function format_amount_with_decimals(amount: big_integer, decimals: integer): text {
    require(decimals &gt;= 0, "Decimals must be non-negative. Received: %s".format(decimals));
    var amt = amount.to_text();
    if (decimals == 0) {
        return amt;
    } else if (amt.size() &gt; decimals) {
        amt = amt.sub(0, amt.size() - decimals) + "." + amt.sub(amt.size() - decimals);
    } else {
        amt = "0." + "0".repeat(decimals - amt.size()) + amt;
    }
    return amt;
}

function get_paginated_asset_balances_by_name(name, page_size: integer, page_cursor: text?) {
    val before_rowid = utils.before_rowid(page_cursor);
    return assets.asset @* {
        .name == name,
        .rowid &gt; (before_rowid ?: rowid(0))
    } (
        utils.pagination_result(
            data = (map_asset($)).to_gtv_pretty(),
            rowid = .rowid
        )
    ) limit utils.fetch_data_size(page_size);
}

function require_zero_exclusive_asset_amount_limits(value: big_integer, name) {
    require(
        value &lt;= max_asset_amount, 
        "%s: value must be lower than 2^256, actual: %d".format(name, value)
    );
    require(
        value &gt; 0L, 
         "%s: value must be non-zero positive, actual: %d".format(name, value)
    );
}

namespace Unsafe {
    function mint(accounts.account, asset, amount: big_integer) {
        require_zero_exclusive_asset_amount_limits(amount, "Parameter amount");
        require(
            asset.issuing_brid == chain_context.blockchain_rid,
            "Assets can only be minted on issuing chain"
        );
        before_mint(account, asset, amount);
        val balance = ensure_balance(account, asset);

        balance.amount += amount;
        asset.total_supply += amount;

        require(asset.total_supply &lt;= max_asset_amount, "End total supply must be lower than 2^256");

        create transfer_history_entry(
            account,
            asset,
            .delta = amount,
            .op_index = op_context.op_index,
            .is_input = false,
            .entry_index = 0,
            transfer_args = [
                [(
                    amount, 
                    account_id = null.to_gtv().to_bytes(), 
                    entry_index = 0
                )],
                [(
                    amount, 
                    account_id = account.id,
                    entry_index = 0
                )]
            ].to_gtv().to_bytes()
        );

        after_mint(account, asset, amount);
    }

    function burn(accounts.account, asset, amount: big_integer) {
        require_zero_exclusive_asset_amount_limits(amount, "Parameter amount");
        require(
            asset.issuing_brid == chain_context.blockchain_rid,
            "Assets can only be burned on issuing chain"
        );
        val balance = balance @ {asset, account};
        require(balance.amount &gt;= amount, "Insufficient balance");

        before_burn(account, asset, amount);

        balance.amount -= amount;
        asset.total_supply -= amount;

        create transfer_history_entry (
            account,
            asset,
            .delta = amount,
            .op_index = op_context.op_index,
            .is_input = true,
            .entry_index = 0,
            transfer_args = [
                [(
                    amount, 
                    account_id = account.id,
                    entry_index = 0
                )],
                [(
                    amount, 
                    account_id = null.to_gtv().to_bytes(), 
                    entry_index = 0
                )]
            ].to_gtv().to_bytes()
        );
        after_burn(account, asset, amount);
    }

    function register_asset(
        name,
        symbol: text,
        decimals: integer,
        blockchain_rid: byte_array,
        icon_url: text): asset {
        require(decimals &gt;= 0 and decimals &lt; 79, "Decimals must be between 0 and 78 (included)");

        val trimmed_icon_url = icon_url.trim();
        require(
            (trimmed_icon_url == "") or (trimmed_icon_url.size() &lt;= 2048 and trimmed_icon_url.matches('^\\S+:\\/\\/[^\\s$.?#].[^\\s]*$')),
            "Invalid URL for icon"
        );

        val id = (name, blockchain_rid).hash();
        return create asset (
            id,
            name,
            symbol,
            decimals,
            issuing_brid=blockchain_rid,
            icon_url=trimmed_icon_url,
            total_supply=0L
        );
    }
}
</string>
                            </entry>
                            <entry key="lib/ft4/assets/extensions.rell">
                                <string>
@extendable function before_transfer(from: accounts.account, to: accounts.account, assets.asset, amount: big_integer);

@extendable function after_transfer(from: accounts.account, to: accounts.account, assets.asset, amount: big_integer);

@extendable function before_mint(accounts.account, asset, amount: big_integer);

@extendable function after_mint(accounts.account, asset, amount: big_integer);

@extendable function before_burn(accounts.account, asset, amount: big_integer);

@extendable function after_burn(accounts.account, asset, amount: big_integer);
</string>
                            </entry>
                            <entry key="lib/ft4/assets/external/module.rell">
                                <string>@mount('ft4')
module;

import ^^.accounts;
import ^^.assets;
import ^^.auth;
import ^^.utils;
</string>
                            </entry>
                            <entry key="lib/ft4/assets/external/operations.rell">
                                <string>
function transfer_message(gtv) {
    val params = struct&lt;transfer&gt;.from_gtv(gtv);
    val asset = assets.Asset(params.asset_id);

    return "Please sign the message\nto transfer %s %s\n(id: %s)\n\nfrom:\n{account_id}\n\nto:\n%s"
        .format(
            assets.format_amount_with_decimals(params.amount, asset.decimals),
            asset.name,
            asset.id,
            params.receiver_id
        );
}

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
    scope = "ft4.transfer",
    flags = ["T"],
    message = transfer_message(*)
);

operation transfer(receiver_id: byte_array, asset_id: byte_array, amount: big_integer) {
    val account = auth.authenticate();
    assets.Unsafe.transfer(account, accounts.Account(receiver_id), assets.Asset(asset_id), amount);
}

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
    scope = "ft4.burn",
    flags = ["T"],
    message = burn_message(*)
);

function burn_message(gtv) {
    val params = struct&lt;burn&gt;.from_gtv(gtv);
    val asset = assets.Asset(params.asset_id);

    return "Please sign the message\nto burn %s %s\n\nfrom:\n{account_id}"
        .format(
            assets.format_amount_with_decimals(params.amount, asset.decimals),
            asset.name
        );
}

operation burn(asset_id: byte_array, amount: big_integer) {
    val account = auth.authenticate();
    assets.Unsafe.burn(account, assets.Asset(asset_id), amount);
}
</string>
                            </entry>
                            <entry key="lib/ft4/assets/external/queries.rell">
                                <string>
query _get_asset_balances(account_id: byte_array) {
    return assets.get_asset_balances(account_id);
}

query get_asset_balances(account_id: byte_array, page_size: integer, page_cursor: text?) {
    return utils.make_page(
        assets.get_paginated_asset_balances(account_id, page_size, page_cursor),
        page_size
    );
}

query get_asset_balance(account_id: byte_array, asset_id: byte_array) {
    return assets.balance @? {
        .account.id == account_id,
        .asset.id == asset_id
    } (
        asset = assets.map_asset(.asset),
        amount = .amount
    );
}

query get_asset_by_name(name) {
    return assets.asset @* { name } ( assets.map_asset($) );
}

query get_assets_by_name(name, page_size: integer, page_cursor: text?) {
    return utils.make_page(
        assets.get_paginated_asset_balances_by_name(name, page_size, page_cursor),
        page_size
    );
}

query get_asset_by_id(asset_id: byte_array) {
    return assets.asset @? { .id == asset_id } ( assets.map_asset($) );
}

query get_asset_by_symbol(symbol: text) {
    return assets.asset @? { .symbol == symbol } ( assets.map_asset($) );
} 

query _get_all_assets() {
    return assets.asset @* {} ( assets.map_asset($) );
}

query get_all_assets(page_size: integer, page_cursor: text?) {
    return utils.make_page(
        assets.get_all_assets(page_size, page_cursor),
        page_size
    );
}

query get_transfer_history(account_id: byte_array, filter: assets.filter, page_size: integer, page_cursor: text?) {
    val account = accounts.account @? { account_id };
    if (empty(account)) return null;

    val paginated_transfers = assets.get_paginated_transfers(account, filter, page_size, page_cursor);
    return utils.make_page(paginated_transfers, page_size);
}

query get_transfer_history_entry(rowid) {
    val entry = assets.transfer_history_entry @? { .rowid == rowid };
    return if (empty(entry)) null else assets.extract_data_from_transfer_history_entry(entry);
}
</string>
                            </entry>
                            <entry key="lib/ft4/assets/history.rell">
                                <string>
@log entity transfer_history_entry {
    index accounts.account, asset;
    delta: big_integer;

    // helps to locate exact position of transfer entry in transaction
    op_index: integer;
    is_input: boolean;
    entry_index: integer;
    transfer_args: byte_array;
}

enum transfer_type {
    sent,
    received,
}

struct filter {
    transfer_type?;
}

function extract_data_from_transfer_history_list(
        entries: list&lt;transfer_history_entry&gt;
    ): list&lt;(data:gtv,rowid:rowid)&gt; {
    return entries @* {} (
        data = extract_data_from_transfer_history_entry($).to_gtv_pretty(),
        rowid = .rowid
    );
}

function extract_operation_name(entry: transfer_history_entry): text {
    val gtx = gtx_transaction.from_gtv(gtv.from_bytes(entry.transaction.tx_data));
    return gtx.body.operations[entry.op_index].name;
}

function extract_data_from_transfer_history_entry(entry: transfer_history_entry) {
    return (
        id = entry.rowid,
        delta = entry.delta,
        decimals = entry.asset.decimals,
        asset = entry.asset.name,
        asset_id = entry.asset.id,
        asset_data = map_asset(entry.asset),
        is_input = entry.is_input,
        timestamp = entry.transaction.block.timestamp,
        block_height = entry.transaction.block.block_height,
        entry_index = entry.entry_index,
        transfer_args = entry.transfer_args,
        tx_rid = entry.transaction.tx_rid,
        tx_data = entry.transaction.tx_data,
        operation_name = extract_operation_name(entry)
    );
}

function get_paginated_transfers(accounts.account, filter, page_size: integer, page_cursor: text?) {
    var before_rowid: rowid? = null;
    if (page_cursor??) {
        val cursor = utils.decode_cursor(page_cursor);
        before_rowid = cursor.before_rowid;
    }

    val entries = transfer_history_entry @* {
        account,
        if (filter.transfer_type == null) true else .is_input == (filter.transfer_type!! == transfer_type.sent), 
        if (before_rowid??) (.rowid &lt; before_rowid) else true
    } (@sort_desc $) limit utils.fetch_data_size(page_size);
    
    return extract_data_from_transfer_history_list(entries) @* {} (
        utils.pagination_result(
            data = .data,
            rowid = .rowid
        )
    );
}
</string>
                            </entry>
                            <entry key="lib/ft4/assets/module.rell">
                                <string>@mount('ft4')
module;

import .external;
import ^.accounts;
import ^.assets;
import ^.utils;
import ^.version;
</string>
                            </entry>
                            <entry key="lib/ft4/assets/transfer.rell">
                                <string>
function deduct_balance(accounts.account, asset, amount: big_integer) {
    val balance = balance @? { account, asset };
    require(balance, "User does not have asset &lt;%s&gt; in account &lt;%s&gt;".format(asset.id, account.id));
    require(balance.amount &gt;= amount, "Balance is too low");
    balance.amount -= amount;
}

namespace Unsafe {
   
   function transfer(from: accounts.account, to: accounts.account, assets.asset, amount: big_integer) {
      require_zero_exclusive_asset_amount_limits(amount, "Parameter amount");
      require(from != to, "Sender and receiver have to be different");

      val args = [
         [(amount, from.id, 0)],
         [(amount, to.id, 0)]
      ];

      before_transfer(from, to, asset, amount);

      deduct_balance(from, asset, amount);
      create transfer_history_entry(
         .account = from,
         .asset = asset,
         .delta = amount,
         .op_index = op_context.op_index,
         .is_input = true,
         .entry_index = 0,
         .transfer_args = args.to_gtv().to_bytes()
      );
      
      ensure_balance(to, asset).amount += amount;
      create transfer_history_entry(
         .account = to,
         .asset = asset,
         .delta = amount,
         .op_index = op_context.op_index,
         .is_input = false,
         .entry_index = 0,
         .transfer_args = args.to_gtv().to_bytes()
      );

      after_transfer(from, to, asset, amount);
   }
}
</string>
                            </entry>
                            <entry key="lib/ft4/auth/authentication.rell">
                                <string>
function authenticate(is_strict: boolean = true) {
    val op = op_context.get_all_operations()[op_context.op_index];

    require(op_context.op_index &gt; 0, "Expected at least two operations, make sure that you included auth operation.");

    val previous_op = op_context.get_all_operations()[op_context.op_index - 1];
    require(
        previous_op.name in ["ft4.evm_auth", "ft4.ft_auth"],
        "Error authenticating operation. Incorrect auth operation %s".format(previous_op.name)
    );

    val account = when (previous_op.name) {
        "ft4.evm_auth" -&gt; _validate_eth_signature(previous_op, is_strict);
        "ft4.ft_auth" -&gt; _validate_ft4_signature(previous_op.args);
        else -&gt; null;
    };

    val valid_account = require(account, "Invalid auth operation: %s".format(previous_op.name));

    accounts.rate_limit(valid_account);

    return valid_account;
}

function get_auth_flags(op_name: name, is_strict: boolean) = get_auth_handler(op_name, is_strict).flags;

function get_auth_message_template(op_name: name, op_args: gtv, is_strict: boolean) {
    val formatter = get_auth_handler(op_name, is_strict).message_formatter;

    val message = if (formatter??) formatter(op_args) else generate_operation_auth_message(chain_context.blockchain_rid, gtx_operation(
        name = op_name,
        args = list&lt;gtv&gt;.from_gtv(op_args)
    ));

    return utils.make_auth_message(message);
}

function _validate_eth_signature(auth_op: gtx_operation, is_strict: boolean): accounts.account {
    val op = op_context.get_all_operations()[op_context.op_index];
    val flags = get_auth_flags(op.name, is_strict);
    val message_template = get_auth_message_template(op.name, op.args.to_gtv(), is_strict);
    val validated_args = _validate_eth_arguments(auth_op.args, set(flags));
    val message = create_message_from_template(
        validated_args, 
        message_template, 
        op.args, 
        validated_args.account_auth_descriptor.ctr
    );

    var recovered_keys = 
        if (validated_args.account_auth_descriptor.auth_type in [accounts.auth_type.S, accounts.auth_type.ES]) [_validate_eth_address(message, validated_args.signatures[0], validated_args.account_auth_descriptor)] 
        else _recover_multiple_eth_keys(message, validated_args.signatures, validated_args.account_auth_descriptor);
    
    validated_args.account_auth_descriptor.ctr += 1;
    
    return validated_args.account;
}

function create_message_from_template(accounts.eth_auth_args, message_template: text, args: list&lt;gtv&gt;, ctr: integer): text {
    require(message_template.contains("{nonce}"), "Message template has to include '{nonce}'");
    require(message_template.contains("{brid}"), "Message template has to include '{brid}'");
    var message = message_template;
    
    // TODO: check if this is still needed
    for (i in range(args.size())) {
        message = message.replace("{%d}".format(i), "%s".format(args[i]).replace("\"", ""));
    }
    
    return message
        .replace("{account_id}", eth_auth_args.account.id.to_hex())
        .replace("{auth_descriptor_id}", eth_auth_args.account_auth_descriptor.id.to_hex())
        .replace("{nonce}", ctr.to_text().replace("\"", ""))
        .replace("{brid}", chain_context.blockchain_rid.to_hex());
}

function _validate_eth_arguments(auth_args: list&lt;gtv&gt;, required_flags: set&lt;text&gt;): accounts.eth_auth_args {
    require(auth_args.size() == 3, "Incorrect number of arguments to auth operation");

    val account_id = byte_array.from_gtv(auth_args[0]);
    val auth_descriptor_id = byte_array.from_gtv(auth_args[1]);
    val signatures = list&lt;signature&gt;.from_gtv(auth_args[2]);

    val account = accounts.Account(account_id);
    
    val auth_descriptor = require(
        accounts.account_auth_descriptor @? { .id == auth_descriptor_id, .account == account },
        "Auth descriptor '%s' not found for account '%s'".format(auth_descriptor_id, account_id)
    );

    require(accounts.is_valid(auth_descriptor));
    
    val has_all_flags = when (auth_descriptor.auth_type) {
        S, ES -&gt; accounts.single_sig_args.from_bytes(auth_descriptor.args).flags.contains_all(required_flags);
        M, EM -&gt; accounts.multi_sig_args.from_bytes(auth_descriptor.args).flags.contains_all(required_flags);
    };
    
    require(has_all_flags, "The auth descriptor does not have the required permissions");

    return accounts.eth_auth_args(account, auth_descriptor, signatures);
}

function _validate_ft4_signature(auth_args: list&lt;gtv&gt;): accounts.account {
    val account_id = byte_array.from_gtv(auth_args[0]);
    val auth_descriptor_id = byte_array.from_gtv(auth_args[1]);
    val flags = get_auth_flags(op_context.get_all_operations()[op_context.op_index].name, is_strict=false);

    val account = accounts.Account(account_id);
    val auth_descriptor = require(
        accounts.account_auth_descriptor @? { .account == account, .id == auth_descriptor_id },
        "Cannot find auth descriptor &lt;%s&gt; for account &lt;%s&gt;".format(auth_descriptor_id, account_id)
    );

    accounts.require_auth(account, auth_descriptor, list(flags));
    return account;
}

function _recover_eth_address(message: text, signature) {
    require(message != "", "Empty messages are not allowed");

    val msg_hash = keccak256(("\u0019Ethereum Signed Message:\n" + message.size().to_text() + message).to_bytes());
    val eth_pubkey = eth_ecrecover(
        signature.r,
        signature.s,
        signature.v - 27,
        msg_hash
    );
    
    return utils.evm_address_from_pubkey(eth_pubkey);
}

function _validate_eth_address(message: text, signature, accounts.account_auth_descriptor) {
    val recovered_address = _recover_eth_address(message, signature);
    val participant = accounts.auth_descriptor_participant @? {
        .account_auth_descriptor == account_auth_descriptor,
        .id == recovered_address
    };
    require(participant, "Invalid signature on message: \n%s".format(message));

    return recovered_address;
}

function _recover_multiple_eth_keys(message: text, signatures: list&lt;signature&gt;, accounts.account_auth_descriptor) {
    var recovered_keys = list&lt;byte_array&gt;();
    for (i in range(signatures.size())) {
        recovered_keys.add(
            _validate_eth_address(
                message,
                signatures[i],
                account_auth_descriptor
            )
        );
    }
    require(
        recovered_keys.size() &gt;= accounts.multi_sig_args.from_bytes(account_auth_descriptor.args).signatures_required, 
        "Minimum number of valid signatures not reached"
    );
    return recovered_keys;
}
</string>
                            </entry>
                            <entry key="lib/ft4/auth/external/module.rell">
                                <string>@mount('ft4')
module;

import ^^.auth;
</string>
                            </entry>
                            <entry key="lib/ft4/auth/external/operations.rell">
                                <string>
operation evm_auth(
    account_id: byte_array,
    auth_descriptor_id: byte_array,
    signatures: list&lt;auth.signature&gt;
) {}

operation ft_auth(
    account_id: byte_array,
    auth_descriptor_id: byte_array
) {}
</string>
                            </entry>
                            <entry key="lib/ft4/auth/external/queries.rell">
                                <string>
query get_auth_flags(op_name: name) = auth.get_auth_handler(op_name, is_strict=false).flags;

query get_auth_message_template(op_name: name, op_args: gtv) = auth.get_auth_message_template(op_name, op_args, is_strict=false);
</string>
                            </entry>
                            <entry key="lib/ft4/auth/login.rell">
                                <string>
val DEFAULT_LOGIN_CONFIG_NAME = "default";

query get_login_config(name? = null) {
    val configs = login_config();
    val config_name = name ?: DEFAULT_LOGIN_CONFIG_NAME;

    if (config_name == DEFAULT_LOGIN_CONFIG_NAME) {
        return if (config_name in configs) configs[config_name] else _login_config(flags = []);
    }
    
    return require(
        configs.get_or_null(config_name), 
        "Unknown login configuration &lt;%s&gt;".format(config_name)
    );
}

struct _login_config {
    flags: list&lt;text&gt;;
}

@extendable
function login_config(): map&lt;name, _login_config&gt;;

function add_login_config(name = DEFAULT_LOGIN_CONFIG_NAME, flags: list&lt;text&gt;) {
    return [name: _login_config(flags)];
}

</string>
                            </entry>
                            <entry key="lib/ft4/auth/module.rell">
                                <string>@mount('ft4')
module;

import ^.accounts;
import ^.utils;
import ^.version;
import .external;

struct auth_data {
    flags: list&lt;text&gt;;
    message: text;
}

struct _auth_handler {
    flags: list&lt;text&gt;;
    message_formatter: ((gtv) -&gt; text)? = null;
}

/*
 * The constant that defines app level authentication scope.
 * If scope is omitted when defining an auth handler, then
 * it has 'app' scope, i.e. it is used to authenticate 
 * operations that do not have own auth handlers or if 
 * there is no mount point auth handler for the operation.
 */
val APP_SCOPE = "app";

/*
 * Extendable function used to define auth handlers. 
 * When called it returns a list of all auth handlers defined
 * in the dapp.
 */
@extendable 
function auth_handler(): map&lt;name, _auth_handler&gt;;

/*
 * Finds auth handler for provided operation name.
 */
function get_auth_handler(op_name: name, is_strict: boolean) {
    require_valid_scope_name(op_name);
    val auth_handlers = auth_handler();
    if (op_name in auth_handlers) return auth_handlers[op_name];

    require(not is_strict, "Strict mode is used and no auth handler matches exactly &lt;%s&gt;".format(op_name));

    val handler = get_mount_scope_auth_handler(auth_handlers, op_name);
    if (handler??) return handler;

    return require(
        auth_handlers.get_or_null(APP_SCOPE), 
        "Cannot find auth handler for operation &lt;%s&gt;".format(op_name)
    );
}

function add_auth_handler(scope: text = APP_SCOPE, flags: list&lt;text&gt;, message: ((gtv) -&gt; text)? = null) {
    val scope_name = scope.trim();
    require_valid_scope_name(scope_name);
    return [scope_name: _auth_handler(flags, message)];
}

function args() = op_context.get_all_operations()[op_context.op_index].args.to_gtv();

struct signature {
    r: byte_array;
    s: byte_array;
    v: integer;
}

function get_mount_scope_auth_handler(auth_handlers: map&lt;name, _auth_handler&gt;, op_name: name) {
    val op_name_components = op_name.split(".");
    if (op_name_components.size() &lt; 2) return null;
    
    for (count in range(op_name_components.size()-1, 0, -1)) {
        val mount_point = join_text_list(op_name_components, count);
        if (mount_point in auth_handlers) return auth_handlers[mount_point];
    }

    return null;
}

/*
 * Creates message from operation name and arguments.
 * It is used when `evm_auth` is used to authenticate a user, 
 * but auth message is not specified in the auth handler of the operation.
 */
function generate_operation_auth_message(brid: byte_array, op: gtx_operation) {
    var message = "Please sign the message to call\noperation:\n- %s".format(op.name);

    if (op.args.size() &gt; 0) {
        message = message + "\n\n";
        var arguments = "with arguments:\n";
        for (arg in op.args) {
            arguments = arguments + "- %s\n".format(arg).replace("\"", "");
        }
        message = message + arguments.sub(0, arguments.size() - 1);
    }
    
    return message;
}

function join_text_list(components: list&lt;text&gt;, count: integer) {
    require(count &lt; components.size() and count &gt; 0, "Error building mount path");
    var result = components[0];
    for (i in range(1, count)) {
        result = result + "." + components[i];
    }
    return result;
}

function require_valid_scope_name(name) =     
    require(
        name.matches("^\\w+(\\.\\w+)*$"), 
        "Invalid scope name &lt;%s&gt;".format(name)
    );
</string>
                            </entry>
                            <entry key="lib/ft4/ft4_basic_dev.rell">
                                <string>module;

namespace ft4 {
    import acc: ^.accounts;
    import ^.accounts;
    import ^.assets;
    import ^.auth;
    import ^.admin;
    import acc_ext: ^.accounts.external;
    import accounts_ext: ^.accounts.external;
    import assets_ext: ^.assets.external;
    import ^.version;
}
</string>
                            </entry>
                            <entry key="lib/ft4/utils/pagination.rell">
                                <string>struct page_cursor {
    before_rowid: rowid? = null;
}

struct pagination_result {
    data: gtv;
    rowid: rowid;
}

val MAX_PAGE_SIZE: integer = 100;

function encode_cursor(page_cursor) = page_cursor.to_bytes().to_base64();

function decode_cursor(cursor: text) = page_cursor.from_bytes(byte_array.from_base64(cursor));

struct paged_result {
    next_cursor: text?;
    data: list&lt;gtv&gt;;
}

function null_page() = paged_result(
    next_cursor = null,
    data = list&lt;gtv&gt;()
);

function fetch_data_size(page_size: integer) = min(MAX_PAGE_SIZE, page_size) + 1;

function before_rowid(page_cursor: text?) {
    var before_rowid: rowid? = null;
    if (page_cursor??) {
        val cursor = decode_cursor(page_cursor);
        before_rowid = cursor.before_rowid;
    }
    return before_rowid;
}


function make_page(pagination_results: list&lt;pagination_result&gt;, page_size: integer): paged_result {
    require(page_size &gt; 0, "Must return at least one item");
    if (empty(pagination_results)) {
         return null_page();
    }
    // adding +1 should help with next page null situation when current page size
    // is equal to max page size
    if(pagination_results.size() &lt; fetch_data_size(page_size)) {
        return paged_result(
            next_cursor = null,
            data = pagination_results  @* {} .data
        );
    }
    val paginated_result = pagination_results.sub(0, pagination_results.size()-1);
    val next_id = pagination_results[pagination_results.size()-2].rowid;
    val next_cursor = page_cursor(
        next_id
    );
    return paged_result(
        next_cursor = encode_cursor(next_cursor),
        data = paginated_result  @* {} .data
    );
}
</string>
                            </entry>
                            <entry key="lib/ft4/utils/utils.rell">
                                <string>/*
 * For complex validation we might not want to use simple "require()"
 * but an error message that is returned. 
 */
struct validation_result {
    valid: boolean;
    error: text? = null;
}

val VALID = validation_result(true, null);

function invalid(error: text) = validation_result(false, error);

function make_auth_message(message: text) {
    return "Blockchain:\n{brid}\n\n" + message + "\n\nNonce: {nonce}";
}

function evm_address_from_pubkey(pubkey) = keccak256(pubkey).sub(12);
</string>
                            </entry>
                            <entry key="lib/ft4/version.rell">
                                <string>@mount('ft4')
module;

query get_version(): text = "0.1.7";
</string>
                            </entry>
                            <entry key="main.rell">
                                <string>module;

import accounts;
import registration.*;
import canvas.*;
import canvas.admin.*;
import voting.*;
import rell_modules.time;
import wallet.*;
import wallet.admin.*;
import leaderboards.*;
import leaderboards.admin.*;

operation init() {
    ft4.admin.require_admin();
    init_canvas();
    create_admin_acc();
    register_asset_if_needed("Obsidian", "OBSN", 10, "https://infinityblocks.art/obsidian-token.png");

    generate_lb(LeaderboardType.TOPPAINTEDCELLS, 60);
    generate_lb(LeaderboardType.TOPVOTED, 60);
}

function register_asset_if_needed(asset_name: name, symbol: text, decimals: integer, icon_url: text) {
    // derive id of the asset
    val asset_id = (asset_name, chain_context.blockchain_rid).hash();
    // check if asset already exist
    if (
        ft4.assets.asset @ ? {
         .id == asset_id
      } ??) return;
    ft4.assets.Unsafe.register_asset(asset_name, symbol, decimals, chain_context.blockchain_rid, icon_url);
}

function create_admin_acc() {
    val auth_descriptor = create_auth_descriptor(ft4.admin.get_admin_pubkey());
    ft4.accounts.Unsafe.create_account_with_auth(auth_descriptor);
}
</string>
                            </entry>
                            <entry key="registration/evm.rell">
                                <string>namespace evm {
    query get_register_message(evm_address: byte_array) =
        "Create account for EVM wallet:\n%s"
        .format(evm_address.to_hex().lower_case());

    function create_account_from_evm(evm_address: byte_array, signature): account {
        val register_msg = get_register_message(evm_address);
        val recovered_address = _recover_eth_address(register_msg, signature);
        require(recovered_address == evm_address, "Signature not valid for the provided key");

        val auth_descriptor = auth_descriptor(
            auth_type = auth_type.ES,
            args = [["A"].to_gtv(), evm_address.to_gtv()],
            rules = null.to_gtv()
        );
        val accountId = Unsafe.create_account_with_auth(auth_descriptor);
        return account @ { accountId };
    }
}</string>
                            </entry>
                            <entry key="registration/module.rell">
                                <string>module;

import accounts.*;
import wallet.*;
import lib.ft4.accounts. {
    add_auth_descriptor_to_account,
    auth_descriptor,
    auth_type,
    single_sig_auth_descriptor,
    Unsafe
};
import lib.ft4.auth. { signature, _recover_eth_address };

operation register_account(name, evm_address: byte_array, signature) {
    require(op_context.get_signers().size() &gt; 0, "Must sign with a session keypair");
    val account = evm.create_account_from_evm(evm_address, signature);
    val user = create user ( name, evm_address, account );
    create_wallet(account);
    add_auth_descriptor_to_account(
        account,
        single_sig_auth_descriptor(
            op_context
                .get_signers()[0],
            set(
                [
                    "MySession"
                ]
            )
        )
    );

    mint_and_give(account, 50);
}
</string>
                            </entry>
                            <entry key="rell_modules/time/constants.rell">
                                <string>function day_in_millis() {
	return 86400000;
}</string>
                            </entry>
                            <entry key="rell_modules/time/module.rell">
                                <string>@mount("time")
module;</string>
                            </entry>
                            <entry key="rell_modules/time/timestamp.rell">
                                <string>function now(): timestamp {
	return block @ { .timestamp &gt; 0 } ( @sort_desc .timestamp ) limit 1;
}

function millis_from_now(millis: integer) {
	return now() + millis;
}

function seconds_from_now(seconds: integer) {
	return now() + (seconds * 1000);
}

function minutes_from_now(minutes: integer) {
	return now() + (minutes * 60 * 1000);
}

function hours_from_now(hours: integer) {
	return now() + (hours * 60 * 60 * 1000);
}

function hours_ago(hours: integer) {
  return now() - (hours * 60 * 60 * 1000);
}

function days_from_now(days: integer) {
	return now() + (days * 24 * 60 * 60 * 1000);
}

function days_ago(days: integer) {
  return now() - (days * 24 * 60 * 60 * 1000);
}</string>
                            </entry>
                            <entry key="test/test_operations.rell">
                                <string>module;

import lib.ft4.accounts.{ Unsafe, single_sig_auth_descriptor };
import accounts.*;

operation create_user_test(name, pubkey) {
  val account_id = Unsafe.create_account_with_auth(single_sig_auth_descriptor(pubkey, set(["MySession"])));
  create user ( name, pubkey, account @ { account_id } );
}</string>
                            </entry>
                            <entry key="voting/functions.rell">
                                <string></string>
                            </entry>
                            <entry key="voting/model.rell">
                                <string>enum voteSentiment {
    UP,
    DOWN
}

entity vote {
    identifier: byte_array;
    voter: user;
    sentiment: voteSentiment;
    votedAt: timestamp;
    key user, cell;
    index cell;
}

struct vote_dto {
    voter: struct&lt;user&gt;;
    sentiment: voteSentiment;
    votedAt: timestamp;
    location: struct&lt;location&gt;;
}</string>
                            </entry>
                            <entry key="voting/module.rell">
                                <string>module;

import canvas.*;
import accounts.*;
import wallet.*;
import leaderboards.*;

import lib.ft4.auth;
import lib.ft4.ft4_basic_dev.*;
</string>
                            </entry>
                            <entry key="voting/operations.rell">
                                <string>operation cast_vote(sentiment: voteSentiment, x: integer, y: integer) {
    val account = auth.authenticate();
    val user = user @ { account };
    val timestamp = op_context.last_block_time;

    require(location @? { .x == x, .y == y }, "You can only vote on cells that are painted");

    val location = location @ { .x == x, .y == y };
    val cell = cell @ { .location == location };

    require(cell.paintedBy != user, "You can not vote on your own cell");
    require(user @? { .account == cell.paintedBy.account }, "Error finding cell owner");

    if (
        not exists(vote
@? { .identifier == cell.hash()
, .voter == user })) {

        mint_and_give(account, 1);

        mint_and_give(cell.paintedBy.account, 1);
        update_lb_participant(LeaderboardType.TOPVOTED, user @ { .account == cell.paintedBy.account });

        create vote (
            .identifier = cell.hash(),
            cell = cell,
            voter = user,
            sentiment = sentiment,
            votedAt = timestamp,
            user = user
        );
    } else {
        require(false, "You have already voted on this cell");
    }
}
</string>
                            </entry>
                            <entry key="voting/queries.rell">
                                <string>query get_votes_by_cell(x: integer, y: integer) {
    val location = location @ { x, y };
    val cell = cell @ { .location == location };
    val votes = vote @* {
        .cell == cell
    } (
        vote_dto( .voter.to_struct(), .sentiment, .votedAt, .cell.location.to_struct() )
    );

    return votes;
}

query get_votes_by_user(account_id: byte_array) {
    val user = user @ { .id == account_id };
    val votes = vote @* {
        .user == user
    } (
        vote_dto( .voter.to_struct(), .sentiment, .votedAt, .cell.location.to_struct() )
    );

    return votes;
}

query get_all_votes(account_id: byte_array) {
    val votes = vote @* { } ( vote_dto( .voter.to_struct(), .sentiment, .votedAt, .cell.location.to_struct() ) );
    return votes;
}
</string>
                            </entry>
                            <entry key="wallet/admin/module.rell">
                                <string>@mount("admin.wallet")
module;

import ^.*;</string>
                            </entry>
                            <entry key="wallet/admin/operations.rell">
                                <string>operation give_tokens(account_id: byte_array, amount: integer) {
    ft4.admin.require_admin();
    val acc = account @ { account_id };
    
    mint_and_give(acc, amount);
}
</string>
                            </entry>
                            <entry key="wallet/functions.rell">
                                <string>function create_wallet(account: account) {
    val token = ft4.assets.asset @ { .name == "Obsidian" };
    ft4.assets.ensure_balance(account, token);
}

function mint_and_give(account: account, amount: integer) {
    val token = ft4.assets.asset @ { .name == "Obsidian" };
    ft4.assets.Unsafe.mint(account, token, amount);
}

function transfer_to(from: account, to: account, amount: integer) {
    val token = ft4.assets.asset @ { .name == "Obsidian" };
    ft4.assets.Unsafe.transfer(from, to, token, amount);
}

function check_balance(account: account) {
    val token = ft4.assets.asset @ { .name == "Obsidian" };
    return ft4.assets.ensure_balance(account, token);
}
</string>
                            </entry>
                            <entry key="wallet/module.rell">
                                <string>module;

import accounts.*;

import lib.ft4.auth;
import lib.ft4.ft4_basic_dev.*;
</string>
                            </entry>
                        </dict>
                    </entry>
                    <entry key="version">
                        <string>0.12.0</string>
                    </entry>
                </dict>
            </entry>
        </dict>
    </entry>
    <entry key="revolt">
        <dict>
            <entry key="fast_revolt_status_timeout">
                <int>2000</int>
            </entry>
        </dict>
    </entry>
</dict>
